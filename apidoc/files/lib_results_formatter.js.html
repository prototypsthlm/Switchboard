<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib&#x2F;results_formatter.js - Switchboard</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Switchboard"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/BaseConnector.html">BaseConnector</a></li>
            
                <li><a href="..&#x2F;classes/ConnectorResponse.html">ConnectorResponse</a></li>
            
                <li><a href="..&#x2F;classes/Echonest.html">Echonest</a></li>
            
                <li><a href="..&#x2F;classes/GoogleBooks.html">GoogleBooks</a></li>
            
                <li><a href="..&#x2F;classes/Lastfm.html">Lastfm</a></li>
            
                <li><a href="..&#x2F;classes/ResultFormatter.html">ResultFormatter</a></li>
            
                <li><a href="..&#x2F;classes/Spotify.html">Spotify</a></li>
            
                <li><a href="..&#x2F;classes/Switchboard.html">Switchboard</a></li>
            
                <li><a href="..&#x2F;classes/SwitchboardJob.html">SwitchboardJob</a></li>
            
                <li><a href="..&#x2F;classes/TestHelper.html">TestHelper</a></li>
            
                <li><a href="..&#x2F;classes/TMDB.html">TMDB</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Connectors.html">Connectors</a></li>
            
                <li><a href="..&#x2F;modules/Switchboard.html">Switchboard</a></li>
            
                <li><a href="..&#x2F;modules/Test.html">Test</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib&#x2F;results_formatter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
* The ResultFormatter takes the response gathered by all connectors 
* and merges them to one formatted result.
*
* @class ResultFormatter
* @constructor
* @param {Array} result Array holding the result gathered from all connectors
*&#x2F;
var $ = require(&#x27;jquery&#x27;);
var jpath = require(&quot;node-jpath&quot;);
var logger = require(&#x27;.&#x2F;sb_tracer.js&#x27;)();

&#x2F;**
* The constructor. The result given to the constructor is always cloned
* to ensure that the raw result isn&#x27;t altered in any way
*
* @method
* @param {Array} result Array holding the result gathered from all connectors. Example: [{api: &quot;Name of Connector A&quot;, calls: []}, {api: &quot;Name of Connector B&quot;, calls: []}]
*&#x2F;

function ResultFormatter(result, config) {    
    
    &#x2F;&#x2F; raw contains the result retrieved by all connectors
    &#x2F;&#x2F; raw cannot be accessed directly to ensure that the result is always cloned
    &#x2F;&#x2F; Otherwise we would end up affecting the raw result while building the clean result
    
    var raw = typeof result != &quot;object&quot; ? [] : $.extend(true, [], result);
    
    var config = {     
        mergeMethod: &#x27;extract&#x27;
    };

    if(typeof config == &quot;object&quot;) {
        this.config = $.extend(true, this.config, config);
    }

    &#x2F;*
        Updates a object with new data given a set of keys that should be traversed
        
        E.g.
        If you want to add data to the artist, e.g. website, you need to use the following data

        var obj = {                                 &#x2F;&#x2F; The object you want to update; 
            artists: {
                artist: {
                    name: &quot;Spice Girls&quot;                    
                }
            },
            events: {...}
        };                                          
        keys = [&#x27;artists&#x27;, &#x27;artist&#x27;, &#x27;website&#x27;];    &#x2F;&#x2F; The keys specifying where the updated value should be set
        value = &#x27;http:&#x2F;&#x2F;www.thespicegirls.com&#x2F;&#x27;;    &#x2F;&#x2F; The value you want to set

        setObjectData(obj, keys, value);

        obj after function is called:

        { 
            artists: {
                artist: {
                    name: &quot;Spice Girls&quot;,
                    website: &#x27;http:&#x2F;&#x2F;www.thespicegirls.com&#x2F;&#x27;                 
                }
            },
            events: {...}
        };   

        @param {Object} obj The object you want to update
        @param {Object} keys An array with keys leading to the location in the object where you want to set your value.
        @param {Mix} value The value you want to set
    *&#x2F;
    var setObjectData = function(obj, keys, value) { 
               
        &#x2F;&#x2F; logger.trace(&quot;setObjectData(obj, keys, value) &quot;, obj, keys, value);
        
        if(obj == undefined) {
            logger.warn(&quot;Object is undefined. Doing nothing&quot;);
            return obj;
        }
        if(keys.length &gt; 1) {
            var key = keys.splice(0,1);
            if(obj[key] instanceof Array) {
                for(var i=0; i &lt; obj[key].length; i++) {
                    return setObjectData(obj[key][i], keys, value);    
                }
            } else {
                return setObjectData(obj[key], keys, value);
            }
            
        }
        
        if(keys[0] == undefined) {
            logger.trace(&quot;Replacing whole object with value&quot;);
            obj = value;
        }
        else {
            var message = (keys[0] in obj ? &quot;Replacing&quot; : &quot;Updating&quot;) + &quot;  value for key &quot;+keys[0];
            logger.trace(message);
            obj[keys[0]] = value;
        }
        
        return obj;
    }

    &#x2F;*
        Goes through the path and finds the first path part that is an array
        e.g.

        obj = [
            {
                &quot;events&quot;: {
                    &quot;event&quot;: [
                        {
                            &quot;artists&quot;: [],
                            &quot;artists&quot;: [],
                            &quot;artists&quot;: [],
                        }
                    ]
                }
            }
        ];

        path = &quot;events.event.artists&quot;;

        returned result would be events.event, since event is an array
    *&#x2F;
    var findArrayPath = function(obj, path, index) {
        logger.trace(&quot;findArrayPath(obj,&quot;,path,&quot;,&quot;,index,&quot;)&quot;);
        var lastPath, objPart;
        index = index == undefined ? 0 : index;

        var pathArray = path.split(&#x27;.&#x27;);
        var pathPart = pathArray[index];  

        if(obj) {
            if(obj[pathPart] instanceof Array) {
                pathArray.splice(index+1,pathArray.length);
                return pathArray.join(&#x27;.&#x27;);
            } else {                
                return findArrayPath(obj[pathPart], path, ++index);
            }
        }
        
        return null;
    }

    var removeUnusedResult = function(connectorResult, inSource, indexToRemove) {
        &#x2F;&#x2F; Locate which path (from the end) in the in source that points to an array
        &#x2F;&#x2F; When found we want to remove that data using the indexToRemove argument
        var pathToArray = findArrayPath(connectorResult, inSource);
        logger.trace(&quot;pathToArray: &quot;, pathToArray);
        
        if(pathToArray) {
            &#x2F;&#x2F; Remove the part that is an array
            var insourceArray = pathToArray.split(&#x27;.&#x27;);
            var keyHoldingArray = insourceArray.pop();
            var path = insourceArray.join(&#x27;.&#x27;);

            if(insourceArray.length) {
                logger.trace(&quot;The key&quot;,keyHoldingArray,path);
                var resultHoldingArray = jpath.filter(connectorResult, path);
                if(resultHoldingArray instanceof Array) {
                    for(var i in resultHoldingArray) {
                        resultHoldingArray[i][keyHoldingArray].splice(indexToRemove,1); &#x2F;&#x2F; remove one at indexToRemove
                    }
                } else {
                    resultHoldingArray[keyHoldingArray].splice(indexToRemove,1);
                }
            }
            else {
                connectorResult[keyHoldingArray].splice(indexToRemove,1);
            }
        } else {
            connectorResult.splice(indexToRemove,1);
        }
    }

    &#x2F;&#x2F; Public function to retrieve the cloned raw data
    this.raw = function() {
        return $.extend(true, [], raw);
    };

    this.config = function(mergeMethod) {
        return mergeMethod in config ? config[mergeMethod] : undefined;
    };

    this.setConfig = function(mergeMethod, value) {
        config[mergeMethod] = value;
    };

    &#x2F;&#x2F; Public function to set the raw result. Always cloned
    this.setRaw = function(rawResult) {
        raw = $.extend(true, [], rawResult);
    };

    &#x2F;&#x2F; Finds a result from a connector and merges the result from the following connector (if found)
    this.findConnectorResult = function(connectorIndex, callIndex, index, returnOnlyResult) {
        
        logger.trace(&quot;this.findConnectorResult(&quot;,connectorIndex,&quot;,&quot;,callIndex,&quot;,&quot;,index,&quot;)&quot;);
        
        var rawResults = this.raw();
        if(!rawResults[connectorIndex]) {
            logger.trace(&quot;No rawResults found for index &quot;+connectorIndex);
            return undefined;
        }

        &#x2F;&#x2F; Holds all calls and their results for a given connector
        var connectorResults = rawResults[connectorIndex];
        
        &#x2F;&#x2F; Hold the connector result for the given input params, i.e. callIndex and index
        var connectorResult = null;

        &#x2F;&#x2F; Go through all calls and find the one we want, i.e. where callIndex and index matches
        &#x2F;&#x2F; When found check if the following connector&#x27;s results exists and add it to the current result

        &#x2F;&#x2F; @todo Fundera på om det går att använda jpath för att hämta rätt resultat istället för att loopa
        for(var i in connectorResults.calls) {
            var connectorCall = connectorResults.calls[i];

            &#x2F;&#x2F; Make sure we are using the results from the right call
            if(!(connectorCall.meta.callIndex == callIndex &amp;&amp; connectorCall.meta.index == index)) {            
                continue;
            }
            
            &#x2F;&#x2F; @todo: Flytta meta.apiConfig till samma ställe som api och calls ligger
            &#x2F;&#x2F; Flytta då in namnet på api i apiConfig. apiConfig kanske ska döpas om oxå
            &#x2F;&#x2F; @todo? Add limit to meta

            &#x2F;&#x2F; @todo: Results generated deeper down in the chain is not removed correctly

            connectorResult = connectorCall;
            &#x2F;&#x2F; Retrieve the next connector&#x27;s results
            var nextConnectorResults = rawResults[connectorIndex+1] ? rawResults[connectorIndex+1] : null;
            if(nextConnectorResults) {
                if(!nextConnectorResults.calls.length) {
                    logger.trace(&quot;No data found in nextConnectorResuls. Leaving...&quot;);
                    break;
                }
                logger.trace(&quot;nextConnectorResults: &quot;, nextConnectorResults);
                
                &#x2F;&#x2F; Flytta så att inte meta.apiConfig ligger i calls utan direkt i &quot;roten&quot;
                &#x2F;&#x2F; apiAction is used as a key when merging the result
                var apiAction = nextConnectorResults.calls[0].meta.apiConfig.action;
                &#x2F;&#x2F; Retrieve the in source
                var inSourceString = nextConnectorResults.calls[0].meta.apiConfig.in_source;
                var nrOfResultsInSource = jpath.filter(connectorResult.result, inSourceString).length;
                &#x2F;&#x2F; Make an array of the in source so that we later can remove the last part of it and store it
                var inSourceArray = inSourceString.split(&#x27;.&#x27;);
                &#x2F;&#x2F; Remove the last part of the in source and store it.
                &#x2F;&#x2F; Is used to detect if the source contains data from an array or not                
                var queryKey = inSourceArray.pop();
                &#x2F;&#x2F; Reset the in source so that it doesn&#x27;t have the last portion of the path
                inSourceString = inSourceArray.join(&#x27;.&#x27;);
                
                &#x2F;&#x2F; @TODO
                &#x2F;&#x2F; Leta efter första arrayen i inSourceString
                &#x2F;&#x2F; Exempel inSource: response.artists.foreign_ids.foreign_id
                &#x2F;&#x2F; Leta efter första arrayen i inSource ovan
                &#x2F;&#x2F; Låt oss säga att den finns vid response.artists
                &#x2F;&#x2F; var result = jpath.filter(connectorResult.result, response.artists)
                &#x2F;&#x2F; for(var i in result) 
                &#x2F;&#x2F; Ta bort response.artists från inSource
                &#x2F;&#x2F; var tmpResult = jpath.filter(result[i], foreign_ids.foreign_id);
                &#x2F;&#x2F; Om vi inte får något resultat, ta bort den result.splice(i,1);
                &#x2F;&#x2F; Om vi får resultat, gör som i loopen nedan
                
                &#x2F;&#x2F; Retrieve all results matching the in source
                var results = jpath.filter(connectorResult.result, inSourceString);

                &#x2F;&#x2F; Array holding all new results since we may want to remove results that
                &#x2F;&#x2F; wasn&#x27;t used by another connector. If merge method is &quot;inject&quot; result is unchanged.
                var newResults = [];

                &#x2F;&#x2F; Go through all results and add the result from next connector
                for(var j = results.length-1; j &gt;= 0; j--) { 
                &#x2F;&#x2F;for(var j = 0; j &lt; results.length; j++) { 
                    var nextConnectorResult = this.findConnectorResult(connectorIndex+1, connectorCall.meta.index, j, false);
                    
                    if(nextConnectorResult) {
                        &#x2F;&#x2F;logger.trace(nextConnectorResults.api, nextConnectorResults.calls[0].meta.apiConfig.in_source,&quot;:&quot;,nextConnectorResult.meta.query);
                        logger.trace(&quot;Result retrieved from the next connector. Result going to be merged in connector &quot;+connectorIndex+&quot;, result at index &quot;+j);
                        
                        &#x2F;&#x2F; Check if the query used by the next connector is retrieved from an array source or not
                        &#x2F;&#x2F; If query was taken from an array we should merge the result in a special way
                        var arrayInSource = results[j][queryKey] instanceof Array;
                        &#x2F;&#x2F; Store the result in a temporary variable
                        var tmpResult = results[j];

                        if(arrayInSource) {
                            &#x2F;&#x2F; If the query used by next connector was retrieved from an array
                            &#x2F;&#x2F; (i.e. the in source points to an array) we collect in an inner
                            &#x2F;&#x2F; loop and adds it to the result.
                            var tmpResults = [nextConnectorResult];
                            while(tmpResults.length &lt; nrOfResultsInSource &amp;&amp; j &gt;= 0) {
                                var conRes = this.findConnectorResult(connectorIndex+1, connectorCall.meta.index, --j, false);                                
                                if(conRes) {
                                    tmpResults.push(conRes);
                                } else {
                                    break;
                                }                       
                            }

                            tmpResult = results[j+1];
                            tmpResult[apiAction] = {};
                             &#x2F;&#x2F; Reverse since we are collecting data from the end to start,
                             &#x2F;&#x2F; But we want the result to be in the right order.
                            tmpResults.reverse();
                            for(var tr in tmpResults) {
                                var res = tmpResults[tr];
                                tmpResult[apiAction][res.meta.query] = res.result;
                            }
                            
                        } else {
                            &#x2F;&#x2F; If the result was retrieved using a query taken from a in source that wasn&#x27;t an array it is pushed to the new result
                            tmpResult[apiAction] = nextConnectorResult.result;
                        }

                    } else if(this.config(&quot;mergeMethod&quot;) == &quot;extract&quot;) {
                        logger.debug(&quot;No result found in connector&quot;,connectorIndex+1,&quot;at index&quot;, j,&quot;using callindex&quot;,connectorCall.meta.index,&quot;. Remove! (extract merge)!&quot;);
                        
                        removeUnusedResult(connectorResult.result, inSourceString, j);
                    }
                }
            }
            
            &#x2F;&#x2F; We have found what we want so we can stop searching
            break;
        }

        &#x2F;&#x2F; If returnOnlyResult == true we return only the generated result from the connector resul, i.e. not meta and raw data
        if(returnOnlyResult) {
            return connectorResult &amp;&amp; &quot;result&quot; in connectorResult ? connectorResult.result : null;
        }
        &#x2F;&#x2F; Return the whole result, i.e. with meta and raw data
        return connectorResult;
    };

}

ResultFormatter.prototype.mergeResult = function(){
    return this.findConnectorResult(0, null, 0, true);
};

ResultFormatter.prototype.injectMerge = function(){
    this.setConfig(&quot;mergeMethod&quot;, &quot;inject&quot;);
    logger.debug(&quot;Using injectMerge&quot;);
    return this.mergeResult();
};

ResultFormatter.prototype.extractMerge = function(){
    this.setConfig(&quot;mergeMethod&quot;, &quot;extract&quot;);
    logger.debug(&quot;Using extractMerge&quot;);
    return this.mergeResult();
};

module.exports = ResultFormatter;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
