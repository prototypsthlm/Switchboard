<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib&#x2F;results_formatter.js - Switchboard</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Switchboard"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/ResultFormatter.html">ResultFormatter</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib&#x2F;results_formatter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
* The ResultFormatter takes the result generated by all connectors
* and merges the result to one big object.
*
* @class ResultFormatter
* @constructor
*&#x2F;

var $ = require(&#x27;jquery&#x27;);
var jpath = require(&quot;node-jpath&quot;);

function ResultFormatter(result) {    
    &#x2F;&#x2F; raw contains the result retrieved by all connectors
    &#x2F;&#x2F; raw cannot be accessed directly to ensure that the result is always cloned
    &#x2F;&#x2F; Otherwise we would end up affecting the raw result while building the clean result
    var raw = typeof result != &quot;object&quot; ? [] : $.extend(true, [], result);
    &#x2F;&#x2F;var raw = typeof result != &quot;object&quot; ? [] : result;
    &#x2F;&#x2F; Public function to retrieve the cloned raw data
    this.raw = function() {
        return $.extend(true, [], raw);
    };

    &#x2F;&#x2F; Public function to set the raw result. Always cloned
    this.setRaw = function(rawResult) {
        raw = $.extend(true, [], rawResult);
    };

}

&#x2F;*  NODEPATHS MED NESTED ARRAYS ?! KOMMER SMÄLLA... *&#x2F;
ResultFormatter.prototype.injectMerge = function(){
   var cleanResult = this.raw();
   $.each(cleanResult, function(i,block){
       if(cleanResult.length-(i+2) &gt;= 0){
           blockInject(cleanResult[cleanResult.length-(i+1)], cleanResult[cleanResult.length-(i+2)]); &#x2F;&#x2F;inject things from child block into parent block
       }
   });
   return cleanResult;
};

ResultFormatter.prototype.extractMerge = function(){
    var cleanResult = [];
    var extractedRestul = null;
    var rawResults = this.raw();
    $.each(rawResults,function(i,block){ &#x2F;&#x2F;this should be a while..?
        
        var index = rawResults.length-i-1;
        console.log(&quot;------- Going through rawResults, i: &quot; + i + &quot;, index: &quot;+index+&quot; i+2==rawResults.length &quot;+(i+2)+&quot;==&quot;+rawResults.length+&quot; ---------&quot;);
        var prevBlock = index-1 &gt;= 0 ? rawResults[index-1] : null;
        
        &#x2F;&#x2F; Since we are building the clean result from the last connector block to the first
        &#x2F;&#x2F; we know that we have reached the end when we don&#x27;t have any previous block and hence no more data to add to the clean result
        if(prevBlock == null) {            
            return cleanResult;
        } 
        
        var currentBlock = rawResults[index];
        var nextBlock = index+1 &lt; rawResults.length ? rawResults[index+1] : null;

        cleanResult = blockExtract(currentBlock, prevBlock, nextBlock);        
    });
   return cleanResult;
}


var setObjectData = function(arr,parts, value) {
    if(parts.length &gt; 1) {
        return setObjectData(arr[part], parts.pop(), value);
    }

    arr[parts[0]] = value;
    
    return arr;
}


var sortByIndex = function(a, b) {
    if(a.meta.index &lt; b.meta.index) return -1;
    if(a.meta.index &gt; b.meta.index) return 1;
    return 0;
};


var blockExtract = function(currentBlock, prevBlock, nextBlock){
        &#x2F;&#x2F;console.log(&quot;blockExtract(childBlock, parentBlock)&quot;, childBlock, parentBlock);
        var nodes = [];
        var leaves = currentBlock.calls;
        leaves.sort(sortByIndex);
        if(prevBlock != null) prevBlock.calls.sort(sortByIndex);
        if(nextBlock != null) nextBlock.calls.sort(sortByIndex);

        $.each(leaves,function(i,leaf){
            var nodePath = leaf.meta.apiConfig.in_source.split(&quot;.&quot;);
            nodePath.pop();
            &#x2F;&#x2F;console.log(&quot;-------------------------&quot;);
            &#x2F;&#x2F;console.log(&quot;ATTACHING: &quot;)
            &#x2F;&#x2F;console.log(leaf);
            &#x2F;&#x2F;console.log(&quot;TO PARENT: &quot;);
            
            var prevBlockResult = prevBlock != undefined ? prevBlock.calls[leaf.meta.callIndex].result : null;
            var resultPart = []; &#x2F;&#x2F;varför måste det vara en array här? om vanlig variabel sätts den inte
            var node = getNode(nodePath, leaf, prevBlockResult);
            &#x2F;&#x2F;nodepath borde här inte vara komplett...frågan är hur den ser ut i olika case&#x27;
            &#x2F;&#x2F;console.log(&quot;node\n&quot;, node);


            &#x2F;&#x2F; If there are a next connector block we store the in_source (e.g. artists.artist.name) it used and the highest index value found
            &#x2F;&#x2F; We need the in_source to determine which results should be removed from leaf.results
            &#x2F;&#x2F; The index is needed to know how many results we should keep from the &quot;in_source&quot; part of leaf.results.
            &#x2F;&#x2F; e.g in_source may be &quot;artists.artist.name&quot;
            &#x2F;&#x2F; Then we know that we should look for leaf.result.artists.artist.name but we need the nextBlockMaxIndex
            &#x2F;&#x2F; to find out how many of these items we should keep
            var nextBlockMaxIndex = 0;
            var nextBlockInSource = &quot;&quot;;
            if(nextBlock != null) {
                for(var i in nextBlock.calls) {
                    var nextBlockCall = nextBlock.calls[i];
                    if(nextBlockCall.meta.callIndex != leaf.meta.index || nextBlockCall.meta.index &lt;= nextBlockMaxIndex) {
                        continue;
                    }

                    nextBlockMaxIndex = nextBlockCall.meta.index;
                    nextBlockInSource = nextBlockCall.meta.apiConfig.in_source;
                }
            }

            if(nextBlockInSource != &quot;&quot;) {
                var inSourceArr = nextBlockInSource.split(&quot;.&quot;);
                &#x2F;&#x2F; Retrieve current result from the inSource pattern (e.g. artists.artist.name)
                inSourceArr = inSourceArr.splice(0,inSourceArr.length-1);
                &#x2F;&#x2F; Remove result that the next connector result didn&#x27;t use in a query
                var inSourceResult = jpath.filter(leaf.result, inSourceArr.join(&quot;.&quot;)).slice(0, nextBlockMaxIndex + 1);
                &#x2F;&#x2F; Update the leaf with the inSourceResult
                &#x2F;&#x2F; This object only contains results that has data that has been used by the next connector
                setObjectData(leaf.result, inSourceArr, inSourceResult);
            }

            injectNode(nodePath, node, leaf);
            nodes.push(node);   
        });
        return nodes;
};

var injectNode =  function(nodePath, node, leaf){
    &#x2F;&#x2F;console.log(&quot;INJECTING NODE&quot;);
    &#x2F;&#x2F;console.log(nodePath);
    &#x2F;&#x2F;console.log(tree);
    var level;
    if (!(node instanceof Array) &amp;&amp; nodePath.length &gt; 0){
        level = nodePath.shift();
    }
    
    if(nodePath.length &gt; 0){
        if(node instanceof Array){ &#x2F;&#x2F;if nested arrays in nodepath this will break.....
            injectNode(nodePath.slice(0), node[leaf.meta.index], leaf); &#x2F;&#x2F;slice(0) =&gt; clone array...
        }
        else if(node[level] != null){
            injectNode(nodePath, node[level], leaf);                    
        }        
    }
    else if(node[level] instanceof Array){
        &#x2F;*console.log(&quot;ARRAY&quot;);
        console.log(leaf);
        console.log(&quot;----&gt;&quot;);
        console.log(node[level][leaf.index]);
        &#x2F;**&#x2F;
        node[level][leaf.meta.index][leaf.meta.apiConfig.action] = leaf.result;
    }
    else if(node[level] != null) {            
        node[level][leaf.meta.apiConfig.action, leaf.result] = leaf.result;
    } else {
        node[leaf.meta.apiConfig.action] = leaf.result;
    }  

};


var getNode =  function(nodePath, leaf, tree){
    &#x2F;&#x2F;console.log(&quot;getNode(nodePath, tree, leaf, objects)&quot;, nodePath, tree, leaf, objects);
    var node = null;
    var level;

    if (!(tree instanceof Array) &amp;&amp; nodePath.length &gt; 0){
        level = nodePath.shift();
    }

    if(nodePath.length &gt; 0) {
        if(tree instanceof Array){ &#x2F;&#x2F;nested arrays....this isn&#x27;t the guaranteed end node              
            node = tree[leaf.meta.index];
        }
        else if(tree[level] != null) {
            node = getNode(nodePath, tree[level], leaf, objects);            
        }
    }
    else {   
        node = tree[level] instanceof Array ? tree[level][leaf.meta.index] : tree[level];
    }    
    
    return node;
};

var blockInject = function(childBlock, parentBlock){
        var leaves = childBlock.calls;
        leaves.sort(sortByIndex);
        parentBlock.calls.sort(sortByIndex);
        $.each(leaves,function(i,leaf){
                var nodePath = leaf.meta.apiConfig.in_source.split(&quot;.&quot;);
                nodePath.pop();
                &#x2F;&#x2F;console.log(&quot;-------------------------&quot;);
                &#x2F;&#x2F;console.log(&quot;ATTACHING: &quot;)
                &#x2F;&#x2F;console.log(leaf);
                &#x2F;&#x2F;console.log(&quot;TO PARENT: &quot;);
                injectNode(nodePath, parentBlock.calls[leaf.meta.callIndex].result, leaf);
        });
        return parentBlock;
};



module.exports = ResultFormatter;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
